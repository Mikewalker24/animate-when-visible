{"version":3,"file":"index.js","sources":["../src/index.js"],"sourcesContent":["/**\n * animateWhenVisible\n * Adds a class to elements when they enter the viewport, with optional stagger and scroll-direction support.\n *\n * @param {Object} options Configuration options\n * @param {number} options.threshold IntersectionObserver threshold\n * @param {number} options.staggerDelay Delay in ms for staggered elements\n * @param {number} options.staggerDelaySlow Delay in ms for slow staggered elements\n * @param {string} options.animationClass Class to add when visible\n * @param {string} options.staggerClass Class that marks elements to stagger\n * @param {string} options.staggerSlowClass Class that marks elements for slow stagger\n * @param {string} options.targetSelector CSS selector for target elements\n * @param {string} options.staggerContainerSelector Class or selector for stagger containers\n * @param {Function} options.onVisible Callback function called when element becomes visible\n * @param {boolean} options.observeMutations Whether to observe dynamically added elements\n * @param {boolean} options.animateOnScrollDownOnly Only animate when scrolling down\n */\nexport default function animateWhenVisible(options = {}) {\n  const cfg = {\n    threshold: 0.1,\n    staggerDelay: 100,\n    staggerDelaySlow: 250,\n    animationClass: 'awv-visible',\n    staggerClass: 'awv-stagger',\n    staggerSlowClass: 'awv-stagger-slow',\n    targetSelector: '.awv-animate',\n    staggerContainerSelector: '.awv-stagger-container',\n    onVisible: null,\n    observeMutations: false,\n    animateOnScrollDownOnly: false,\n    ...options,\n  };\n\n  const elementIndex = new Map();\n  let orderCounter = 0;\n  const staggeredCountByContainer = new Map();\n  let lastScrollY = window.scrollY;\n\n  function handleIntersect(entries) {\n    const currentScrollY = window.scrollY;\n    const scrollingDown = currentScrollY > lastScrollY;\n    lastScrollY = currentScrollY;\n\n    entries\n      .filter((e) => e.isIntersecting)\n      // .sort((a, b) => elementIndex.get(a.target) - elementIndex.get(b.target))\n      .forEach((entry) => {\n        if (cfg.animateOnScrollDownOnly && !scrollingDown) return;\n\n        const el = entry.target;\n        const hasStagger =\n          el.classList.contains(cfg.staggerClass) ||\n          el.classList.contains(cfg.staggerSlowClass);\n\n        if (!hasStagger) {\n          animateImmediate(el);\n          return;\n        }\n\n        const container = getStaggerContainer(el);\n        animateWithStagger(el, container);\n      });\n  }\n\n  const observer = new IntersectionObserver(handleIntersect, {\n    threshold: cfg.threshold,\n  });\n\n  function observeElements(els) {\n    els.forEach((el) => {\n      if (!elementIndex.has(el)) elementIndex.set(el, orderCounter++);\n      observer.observe(el);\n    });\n  }\n\n  observeElements(document.querySelectorAll(cfg.targetSelector));\n\n  let mutationObserver;\n  if (cfg.observeMutations) {\n    mutationObserver = new MutationObserver(function handleMutations(\n      mutations\n    ) {\n      const newEls = new Set();\n      mutations.forEach((m) =>\n        m.addedNodes.forEach((n) => {\n          if (n.nodeType !== 1) return;\n          if (n.matches(cfg.targetSelector)) newEls.add(n);\n          else\n            n.querySelectorAll(cfg.targetSelector).forEach((child) =>\n              newEls.add(child)\n            );\n        })\n      );\n      if (newEls.size) observeElements([...newEls]);\n    });\n    mutationObserver.observe(document.body, { childList: true, subtree: true });\n  }\n\n  function getStaggerContainer(el) {\n    return (\n      el.closest(cfg.staggerContainerSelector) ||\n      el.closest('section') ||\n      el.closest('nav') ||\n      document.body\n    );\n  }\n\n  function getStaggerDelay(el, container) {\n    const animatedCount = staggeredCountByContainer.get(container) ?? 0;\n\n    if (el.classList.contains(cfg.staggerSlowClass)) {\n      return `${animatedCount * cfg.staggerDelaySlow}ms`;\n    }\n    if (el.classList.contains(cfg.staggerClass)) {\n      return `${animatedCount * cfg.staggerDelay}ms`;\n    }\n    return '0ms';\n  }\n\n  function animateImmediate(el) {\n    el.classList.add(cfg.animationClass);\n    if (typeof cfg.onVisible === 'function') cfg.onVisible(el);\n    observer.unobserve(el);\n  }\n\n  function animateWithStagger(el, container) {\n    if (!staggeredCountByContainer.has(container)) {\n      staggeredCountByContainer.set(container, 0);\n    }\n\n    const delay = getStaggerDelay(el, container);\n\n    requestAnimationFrame(() => {\n      el.style.transitionDelay = delay;\n      el.classList.add(cfg.animationClass);\n\n      el.addEventListener(\n        'transitionend',\n        () => (el.style.transitionDelay = '0ms'),\n        { once: true }\n      );\n\n      if (typeof cfg.onVisible === 'function') cfg.onVisible(el);\n    });\n\n    staggeredCountByContainer.set(\n      container,\n      staggeredCountByContainer.get(container) + 1\n    );\n    observer.unobserve(el);\n  }\n\n  return {\n    destroy() {\n      observer.disconnect();\n      if (mutationObserver) mutationObserver.disconnect();\n    },\n    refresh() {\n      observeElements(document.querySelectorAll(cfg.targetSelector));\n    },\n  };\n}\n"],"names":["animateWhenVisible","options","cfg","threshold","staggerDelay","staggerDelaySlow","animationClass","staggerClass","staggerSlowClass","targetSelector","staggerContainerSelector","onVisible","observeMutations","animateOnScrollDownOnly","elementIndex","Map","orderCounter","staggeredCountByContainer","lastScrollY","window","scrollY","observer","IntersectionObserver","handleIntersect","entries","currentScrollY","scrollingDown","filter","e","isIntersecting","forEach","entry","el","target","classList","contains","animateImmediate","add","unobserve","container","getStaggerContainer","closest","document","body","animateWithStagger","has","set","delay","getStaggerDelay","animatedCount","get","requestAnimationFrame","style","transitionDelay","addEventListener","once","observeElements","els","observe","mutationObserver","querySelectorAll","MutationObserver","handleMutations","mutations","newEls","Set","m","addedNodes","n","nodeType","matches","child","size","childList","subtree","destroy","disconnect","refresh"],"mappings":"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"}