{"version":3,"file":"index.js","sources":["../src/index.js"],"sourcesContent":["/**\n * animateWhenVisible\n * Adds a class to elements when they enter the viewport, with optional stagger and scroll-direction support.\n *\n * @param {Object} options Configuration options\n * @param {number} options.threshold IntersectionObserver threshold\n * @param {number} options.staggerDelay Delay in ms for staggered elements\n * @param {number} options.staggerDelaySlow Delay in ms for slow staggered elements\n * @param {string} options.animationClass Class to add when visible\n * @param {string} options.staggerClass Class that marks elements to stagger\n * @param {string} options.staggerSlowClass Class that marks elements for slow stagger\n * @param {string} options.targetSelector CSS selector for target elements\n * @param {string} options.staggerContainerSelector Class or selector for stagger containers\n * @param {Function} options.onVisible Callback function called when element becomes visible\n * @param {boolean} options.observeMutations Whether to observe dynamically added elements\n * @param {boolean} options.animateOnScrollDownOnly Only animate when scrolling down\n */\nexport default function animateWhenVisible(options = {}) {\n  const cfg = {\n    threshold: 0.1,\n    staggerDelay: 100,\n    staggerDelaySlow: 250,\n    animationClass: 'awv-visible',\n    staggerClass: 'awv-stagger',\n    staggerSlowClass: 'awv-stagger-slow',\n    targetSelector: '.awv-animate',\n    staggerContainerSelector: '.awv-stagger-container',\n    onVisible: null,\n    observeMutations: false,\n    animateOnScrollDownOnly: false,\n    ...options,\n  };\n\n  const elementIndex = new Map();\n  let orderCounter = 0;\n  const staggeredCountByContainer = new Map();\n  let lastScrollY = window.scrollY;\n\n  function handleIntersect(entries) {\n    const currentScrollY = window.scrollY;\n    const scrollingDown = currentScrollY > lastScrollY;\n    lastScrollY = currentScrollY;\n\n    entries\n      .filter((e) => e.isIntersecting)\n      .sort((a, b) => elementIndex.get(a.target) - elementIndex.get(b.target))\n      .forEach((entry) => {\n        if (cfg.animateOnScrollDownOnly && !scrollingDown) return;\n\n        const el = entry.target;\n        const hasStagger =\n          el.classList.contains(cfg.staggerClass) ||\n          el.classList.contains(cfg.staggerSlowClass);\n\n        if (!hasStagger) {\n          animateImmediate(el);\n          return;\n        }\n\n        const container = getStaggerContainer(el);\n        animateWithStagger(el, container);\n      });\n  }\n\n  const observer = new IntersectionObserver(handleIntersect, {\n    threshold: cfg.threshold,\n  });\n\n  function observeElements(els) {\n    els.forEach((el) => {\n      if (!elementIndex.has(el)) elementIndex.set(el, orderCounter++);\n      observer.observe(el);\n    });\n  }\n\n  observeElements(document.querySelectorAll(cfg.targetSelector));\n\n  let mutationObserver;\n  if (cfg.observeMutations) {\n    mutationObserver = new MutationObserver(function handleMutations(\n      mutations\n    ) {\n      const newEls = new Set();\n      mutations.forEach((m) =>\n        m.addedNodes.forEach((n) => {\n          if (n.nodeType !== 1) return;\n          if (n.matches(cfg.targetSelector)) newEls.add(n);\n          else\n            n.querySelectorAll(cfg.targetSelector).forEach((child) =>\n              newEls.add(child)\n            );\n        })\n      );\n      if (newEls.size) observeElements([...newEls]);\n    });\n    mutationObserver.observe(document.body, { childList: true, subtree: true });\n  }\n\n  function getStaggerContainer(el) {\n    return (\n      el.closest(cfg.staggerContainerSelector) ||\n      el.closest('section') ||\n      el.closest('nav') ||\n      document.body\n    );\n  }\n\n  function getStaggerDelay(el, container) {\n    const animatedCount = staggeredCountByContainer.get(container) ?? 0;\n\n    if (el.classList.contains(cfg.staggerSlowClass)) {\n      return `${animatedCount * cfg.staggerDelaySlow}ms`;\n    }\n    if (el.classList.contains(cfg.staggerClass)) {\n      return `${animatedCount * cfg.staggerDelay}ms`;\n    }\n    return '0ms';\n  }\n\n  function animateImmediate(el) {\n    el.classList.add(cfg.animationClass);\n    if (typeof cfg.onVisible === 'function') cfg.onVisible(el);\n    observer.unobserve(el);\n  }\n\n  function animateWithStagger(el, container) {\n    if (!staggeredCountByContainer.has(container)) {\n      staggeredCountByContainer.set(container, 0);\n    }\n\n    const delay = getStaggerDelay(el, container);\n\n    requestAnimationFrame(() => {\n      el.style.transitionDelay = delay;\n      el.classList.add(cfg.animationClass);\n\n      el.addEventListener(\n        'transitionend',\n        () => (el.style.transitionDelay = '0ms'),\n        { once: true }\n      );\n\n      if (typeof cfg.onVisible === 'function') cfg.onVisible(el);\n    });\n\n    staggeredCountByContainer.set(\n      container,\n      staggeredCountByContainer.get(container) + 1\n    );\n    observer.unobserve(el);\n  }\n\n  return {\n    destroy() {\n      observer.disconnect();\n      if (mutationObserver) mutationObserver.disconnect();\n    },\n    refresh() {\n      observeElements(document.querySelectorAll(cfg.targetSelector));\n    },\n  };\n}\n"],"names":["animateWhenVisible","options","cfg","threshold","staggerDelay","staggerDelaySlow","animationClass","staggerClass","staggerSlowClass","targetSelector","staggerContainerSelector","onVisible","observeMutations","animateOnScrollDownOnly","elementIndex","Map","orderCounter","staggeredCountByContainer","lastScrollY","window","scrollY","observer","IntersectionObserver","handleIntersect","entries","currentScrollY","scrollingDown","filter","e","isIntersecting","sort","a","b","get","target","forEach","entry","el","classList","contains","animateImmediate","add","unobserve","container","getStaggerContainer","closest","document","body","animateWithStagger","has","set","delay","getStaggerDelay","animatedCount","requestAnimationFrame","style","transitionDelay","addEventListener","once","observeElements","els","observe","mutationObserver","querySelectorAll","MutationObserver","handleMutations","mutations","newEls","Set","m","addedNodes","n","nodeType","matches","child","size","childList","subtree","destroy","disconnect","refresh"],"mappings":"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"}